<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ë–∞–Ω—è –î–æ–¥–æ–≤ üî•</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            font-family: 'Press Start 2P', cursive;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a0000 0%, #4a1010 50%, #1a0000 100%);
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameCanvas {
            border: 4px solid #ff6b35;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 107, 53, 0.5);
            max-width: 100%;
            height: auto;
        }
        
        .steam {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: steamRise 2s infinite;
        }
        
        @keyframes steamRise {
            0% { transform: translateY(0) scale(1); opacity: 0.5; }
            100% { transform: translateY(-100px) scale(2); opacity: 0; }
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }
        
        .shake {
            animation: shake 0.3s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .speech-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 10px;
            color: #333;
            max-width: 150px;
            animation: bubblePop 0.3s ease-out;
            pointer-events: none;
            z-index: 100;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.95) transparent transparent;
        }
        
        .speech-bubble.enemy {
            background: rgba(255, 100, 100, 0.95);
            color: #500;
        }
        
        .speech-bubble.enemy::after {
            border-color: rgba(255, 100, 100, 0.95) transparent transparent;
        }
        
        @keyframes bubblePop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes bubbleFade {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        /* Joystick Styles */
        #joystickContainer {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 1000;
            display: none;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 107, 53, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
        }
        
        #joystickHandle {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ff6b35, #ff4500);
            border: 2px solid #fff;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.7);
        }
        
        #mobileControls {
            display: none;
        }
        
        /* Show joystick on touch devices */
        @media (pointer: coarse) {
            #joystickContainer {
                display: block;
            }
            #mobileControls {
                display: block;
            }
            #gameCanvas {
                max-height: 50vh;
            }
        }
        
        /* Fullscreen button */
        #fullscreenBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 107, 53, 0.8);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 10px;
            display: none;
        }
        
        @media (pointer: coarse) {
            #fullscreenBtn {
                display: block;
            }
        }
        
        /* Shop Styles */
        #shopModal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        #shopModal.hidden {
            display: none !important;
        }
        
        #shopModal:not(.hidden) {
            display: flex;
        }
        
        .shop-item {
            background: linear-gradient(135deg, #2a1a0a, #3d2914);
            border: 2px solid #ff6b35;
            border-radius: 15px;
            padding: 15px;
            margin: 10px;
            transition: all 0.3s;
            cursor: pointer;
        }
        
        .shop-item:hover {
            transform: scale(1.05);
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .shop-item.maxed {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .shop-item.maxed:hover {
            transform: none;
            border-color: #ff6b35;
            box-shadow: none;
        }
        
        /* Shield button for mobile */
        #shieldBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00bfff, #0066ff);
            border: 3px solid #fff;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.5);
        }
        
        #shieldBtn.on-cooldown {
            background: linear-gradient(135deg, #555, #333);
            opacity: 0.6;
        }
        
        @media (pointer: coarse) {
            #shieldBtn {
                display: flex;
            }
        }
        
        /* Coin animation */
        @keyframes coinFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        
        .coin-popup {
            position: absolute;
            color: #ffd700;
            font-size: 14px;
            pointer-events: none;
            animation: coinFloat 1s ease-out forwards;
            text-shadow: 0 0 10px #ffd700;
        }
        
        /* Shield effect */
        @keyframes shieldPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 191, 255, 0.8); }
            50% { box-shadow: 0 0 40px rgba(0, 191, 255, 1); }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <!-- Fullscreen button for mobile -->
    <button id="fullscreenBtn" onclick="toggleFullscreen()">‚õ∂ –ü–û–õ–ù–´–ô –≠–ö–†–ê–ù</button>

    <!-- Start Screen -->
    <div id="startScreen" class="text-center">
        <h1 class="text-3xl md:text-5xl text-orange-500 mb-8 glow">üî• –ë–ê–ù–Ø –î–û–î–û–í üî•</h1>
        <p class="text-white text-xs md:text-sm mb-4">–¢—ã - "–°—ã—Ä". –ó–∞–π–¥–∏ –≤ –±–∞–Ω—é –∏ —Å—Ç–∞–Ω—å –ª–µ–≥–µ–Ω–¥–æ–π!</p>
        <p class="text-yellow-300 text-xs mb-2">–ü–ö: WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏ | –ü–†–û–ë–ï–õ - —â–∏—Ç</p>
        <p class="text-yellow-300 text-xs mb-6" id="mobileControls">üì± –¢–µ–ª–µ—Ñ–æ–Ω: –î–∂–æ–π—Å—Ç–∏–∫ —Å–ª–µ–≤–∞, —â–∏—Ç —Å–ø—Ä–∞–≤–∞</p>
        
        <div class="flex flex-col gap-4 items-center">
            <button onclick="startGame()" class="bg-orange-600 hover:bg-orange-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                –í–û–ô–¢–ò –í –ë–ê–ù–Æ
            </button>
            <button onclick="openShop()" class="bg-yellow-600 hover:bg-yellow-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                üõí –ú–ê–ì–ê–ó–ò–ù
            </button>
        </div>
        
        <div class="mt-6 text-yellow-400 text-sm">
            üí∞ –ú–æ–Ω–µ—Ç—ã: <span id="startCoins">0</span>
        </div>
        
        <div class="mt-4 text-xs text-gray-400">
            <p>‚ö†Ô∏è –° –∫–∞–∂–¥–æ–π —Ñ–æ—Ä–º–æ–π –°–õ–û–ñ–ù–ï–ï!</p>
            <p class="mt-2">–ó–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π –º–æ–Ω–µ—Ç—ã –∏ —É–ª—É—á—à–∞–π—Å—è!</p>
        </div>
    </div>

    <!-- Shop Modal -->
    <div id="shopModal" class="hidden">
        <div class="bg-gradient-to-b from-gray-900 to-gray-800 p-6 rounded-2xl border-4 border-orange-500 max-w-lg w-full mx-4 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl text-orange-400 glow">üõí –ú–ê–ì–ê–ó–ò–ù</h2>
                <div class="text-yellow-400 text-sm">üí∞ <span id="shopCoins">0</span></div>
            </div>
            
            <div class="grid gap-4">
                <!-- HP Upgrade -->
                <div class="shop-item" id="shopHP" onclick="buyUpgrade('hp')">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-green-400 text-sm">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï</span>
                        <span class="text-yellow-300 text-xs">–£—Ä. <span id="hpLevel">0</span>/5</span>
                    </div>
                    <p class="text-gray-300 text-xs mb-2">+20 –∫ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º—É HP</p>
                    <div class="text-yellow-400 text-sm">üí∞ <span id="hpCost">100</span></div>
                </div>
                
                <!-- XP Boost -->
                <div class="shop-item" id="shopXP" onclick="buyUpgrade('xp')">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-purple-400 text-sm">‚ö° XP –ë–£–°–¢</span>
                        <span class="text-yellow-300 text-xs">–£—Ä. <span id="xpLevel">0</span>/5</span>
                    </div>
                    <p class="text-gray-300 text-xs mb-2">+25% –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ –Ω–∞–±–æ—Ä–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã</p>
                    <div class="text-yellow-400 text-sm">üí∞ <span id="xpCost">150</span></div>
                </div>
                
                <!-- Shield -->
                <div class="shop-item" id="shopShield" onclick="buyUpgrade('shield')">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-cyan-400 text-sm">üõ°Ô∏è –©–ò–¢</span>
                        <span class="text-yellow-300 text-xs">–£—Ä. <span id="shieldLevel">0</span>/5</span>
                    </div>
                    <p class="text-gray-300 text-xs mb-2">+1 —Å–µ–∫ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —â–∏—Ç–∞</p>
                    <div class="text-yellow-400 text-sm">üí∞ <span id="shieldCost">200</span></div>
                </div>
                
                <!-- Shield Cooldown -->
                <div class="shop-item" id="shopCooldown" onclick="buyUpgrade('cooldown')">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-blue-400 text-sm">‚è±Ô∏è –ü–ï–†–ï–ó–ê–†–Ø–î–ö–ê</span>
                        <span class="text-yellow-300 text-xs">–£—Ä. <span id="cooldownLevel">0</span>/5</span>
                    </div>
                    <p class="text-gray-300 text-xs mb-2">-2 —Å–µ–∫ –∫ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–µ —â–∏—Ç–∞</p>
                    <div class="text-yellow-400 text-sm">üí∞ <span id="cooldownCost">175</span></div>
                </div>
            </div>
            
            <button onclick="closeShop()" class="mt-6 w-full bg-red-600 hover:bg-red-700 text-white py-3 rounded-lg text-sm transition-all">
                –ó–ê–ö–†–´–¢–¨
            </button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="hidden flex-col items-center">
        <div class="flex justify-between w-full max-w-2xl mb-4 px-2 flex-wrap gap-2">
            <div class="text-white text-xs">
                <span class="text-orange-400">–§–û–†–ú–ê:</span> 
                <span id="playerForm" class="text-yellow-300">–ß</span>
            </div>
            <div class="text-white text-xs">
                <span class="text-yellow-400">üí∞</span> 
                <span id="coins" class="text-yellow-300">0</span>
            </div>
            <div class="text-white text-xs">
                <span class="text-red-400">üå°Ô∏è</span> 
                <span id="temperature" class="text-red-300">0</span>¬∞C
            </div>
            <div class="text-white text-xs">
                <span class="text-green-400">‚ù§Ô∏è</span> 
                <span id="health" class="text-green-300">100</span>
            </div>
            <div class="text-white text-xs">
                <span class="text-cyan-400">üõ°Ô∏è</span> 
                <span id="shieldStatus" class="text-cyan-300">–ì–æ—Ç–æ–≤</span>
            </div>
        </div>
        
        <div class="relative">
            <canvas id="gameCanvas" width="700" height="500"></canvas>
            <div id="steamContainer" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
            <div id="speechContainer" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
            <div id="coinContainer" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
        </div>
        
        <div class="mt-4 text-center">
            <p class="text-orange-300 text-xs" id="enemyInfo">–ì–æ—Ç–æ–≤—å—Å—è –∫ –±–æ—é!</p>
            <div class="w-full bg-gray-700 rounded-full h-4 mt-2" style="width: 300px; max-width: 90vw;">
                <div id="tempBar" class="bg-gradient-to-r from-orange-500 to-red-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-xs mt-1">–î–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: <span id="nextForm">1000¬∞C</span></p>
            <p class="text-red-400 text-xs mt-1" id="difficultyInfo">–°–ª–æ–∂–Ω–æ—Å—Ç—å: ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ</p>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden text-center">
        <h2 class="text-4xl text-red-500 mb-4 glow">üíÄ –°–ì–û–†–ï–õ! üíÄ</h2>
        <p class="text-white text-sm mb-2">–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞—è —Ñ–æ—Ä–º–∞: <span id="finalForm" class="text-yellow-300"></span></p>
        <p class="text-orange-300 text-sm mb-2">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: <span id="finalTemp"></span>¬∞C</p>
        <p class="text-yellow-400 text-sm mb-2">–ó–∞—Ä–∞–±–æ—Ç–∞–Ω–æ –º–æ–Ω–µ—Ç: <span id="earnedCoins"></span> üí∞</p>
        <p class="text-purple-300 text-sm mb-6">–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏: <span id="finalLevel"></span></p>
        <div class="flex flex-col gap-3 items-center">
            <button onclick="restartGame()" class="bg-orange-600 hover:bg-orange-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                –°–ù–û–í–ê –í –ë–ê–ù–Æ
            </button>
            <button onclick="goToMenu()" class="bg-gray-600 hover:bg-gray-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                –í –ú–ï–ù–Æ
            </button>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="hidden text-center">
        <h2 class="text-3xl text-yellow-400 mb-4 glow pulse">üëë –õ–ï–ì–ï–ù–î–ê –ë–ê–ù–ò! üëë</h2>
        <p class="text-white text-sm mb-2">–¢—ã —Å—Ç–∞–ª:</p>
        <p class="text-2xl text-orange-400 mb-4 glow">–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞ –°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–ø—Ä–∞–¥–æ–¥–æ—Å!</p>
        <p class="text-yellow-400 text-sm mb-2">–ë–æ–Ω—É—Å –∑–∞ –ø–æ–±–µ–¥—É: +500 üí∞</p>
        <p class="text-green-300 text-sm mb-6">–¢—ã –ø–æ–±–µ–¥–∏–ª –í–°–ï —É—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏!</p>
        <div class="flex flex-col gap-3 items-center">
            <button onclick="restartGame()" class="bg-yellow-600 hover:bg-yellow-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                –ù–ê–ß–ê–¢–¨ –ó–ê–ù–û–í–û
            </button>
            <button onclick="goToMenu()" class="bg-gray-600 hover:bg-gray-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
                –í –ú–ï–ù–Æ
            </button>
        </div>
    </div>

    <!-- Virtual Joystick -->
    <div id="joystickContainer">
        <div id="joystickBase"></div>
        <div id="joystickHandle"></div>
    </div>
    
    <!-- Shield Button for Mobile -->
    <button id="shieldBtn" onclick="activateShield()">üõ°Ô∏è</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Save System
        let saveData = {
            coins: 0,
            upgrades: {
                hp: 0,      // Max 5 (+20 HP each)
                xp: 0,      // Max 5 (+25% temp rate each)
                shield: 0,  // Max 5 (+1 sec each)
                cooldown: 0 // Max 5 (-2 sec each)
            }
        };
        
        // Load save data
        function loadSave() {
            const saved = localStorage.getItem('banyaDodsave');
            if (saved) {
                try {
                    saveData = JSON.parse(saved);
                } catch (e) {
                    console.log('Save corrupted, starting fresh');
                }
            }
            updateShopUI();
        }
        
        function saveSave() {
            localStorage.setItem('banyaDodsave', JSON.stringify(saveData));
        }
        
        // Shop Functions
        const UPGRADE_COSTS = {
            hp: [1000, 2000, 4000, 8000, 15000],
            xp: [1500, 3000, 6000, 12000, 20000],
            shield: [2000, 4000, 8000, 16000, 30000],
            cooldown: [1750, 3500, 7000, 14000, 25000]
        };
        
        function openShop() {
            document.getElementById('shopModal').classList.remove('hidden');
            updateShopUI();
        }
        
        function closeShop() {
            document.getElementById('shopModal').classList.add('hidden');
        }
        
        function updateShopUI() {
            document.getElementById('startCoins').textContent = saveData.coins;
            document.getElementById('shopCoins').textContent = saveData.coins;
            
            // HP
            const hpLevel = saveData.upgrades.hp;
            document.getElementById('hpLevel').textContent = hpLevel;
            document.getElementById('hpCost').textContent = hpLevel >= 5 ? 'MAX' : UPGRADE_COSTS.hp[hpLevel];
            document.getElementById('shopHP').classList.toggle('maxed', hpLevel >= 5);
            
            // XP
            const xpLevel = saveData.upgrades.xp;
            document.getElementById('xpLevel').textContent = xpLevel;
            document.getElementById('xpCost').textContent = xpLevel >= 5 ? 'MAX' : UPGRADE_COSTS.xp[xpLevel];
            document.getElementById('shopXP').classList.toggle('maxed', xpLevel >= 5);
            
            // Shield
            const shieldLevel = saveData.upgrades.shield;
            document.getElementById('shieldLevel').textContent = shieldLevel;
            document.getElementById('shieldCost').textContent = shieldLevel >= 5 ? 'MAX' : UPGRADE_COSTS.shield[shieldLevel];
            document.getElementById('shopShield').classList.toggle('maxed', shieldLevel >= 5);
            
            // Cooldown
            const cooldownLevel = saveData.upgrades.cooldown;
            document.getElementById('cooldownLevel').textContent = cooldownLevel;
            document.getElementById('cooldownCost').textContent = cooldownLevel >= 5 ? 'MAX' : UPGRADE_COSTS.cooldown[cooldownLevel];
            document.getElementById('shopCooldown').classList.toggle('maxed', cooldownLevel >= 5);
        }
        
        function buyUpgrade(type) {
            const level = saveData.upgrades[type];
            if (level >= 5) return;
            
            const cost = UPGRADE_COSTS[type][level];
            if (saveData.coins >= cost) {
                saveData.coins -= cost;
                saveData.upgrades[type]++;
                saveSave();
                updateShopUI();
                
                // Visual feedback
                const element = document.getElementById('shop' + type.charAt(0).toUpperCase() + type.slice(1));
                element.style.transform = 'scale(1.1)';
                setTimeout(() => element.style.transform = '', 200);
            }
        }
        
        function getMaxHealth() {
            return 100 + saveData.upgrades.hp * 20;
        }
        
        function getXPMultiplier() {
            return 1 + saveData.upgrades.xp * 0.25;
        }
        
        function getShieldDuration() {
            return 2 + saveData.upgrades.shield; // Base 2 sec + upgrades
        }
        
        function getShieldCooldown() {
            return 15 - saveData.upgrades.cooldown * 2; // Base 15 sec - upgrades
        }
        
        // Joystick variables
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const joystickBase = document.getElementById('joystickBase');
        
        let joystick = {
            active: false,
            startX: 0,
            startY: 0,
            moveX: 0,
            moveY: 0,
            touchId: null
        };
        
        const joystickMaxDistance = 45;
        
        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // Joystick touch events
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            joystick.active = true;
            joystick.touchId = touch.identifier;
            
            const rect = joystickBase.getBoundingClientRect();
            joystick.startX = rect.left + rect.width / 2;
            joystick.startY = rect.top + rect.height / 2;
            
            updateJoystickPosition(touch.clientX, touch.clientY);
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!joystick.active) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === joystick.touchId) {
                    e.preventDefault();
                    updateJoystickPosition(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystick.touchId) {
                    resetJoystick();
                    break;
                }
            }
        });
        
        document.addEventListener('touchcancel', (e) => {
            resetJoystick();
        });
        
        function updateJoystickPosition(touchX, touchY) {
            let deltaX = touchX - joystick.startX;
            let deltaY = touchY - joystick.startY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > joystickMaxDistance) {
                deltaX = (deltaX / distance) * joystickMaxDistance;
                deltaY = (deltaY / distance) * joystickMaxDistance;
            }
            
            joystickHandle.style.left = `calc(50% + ${deltaX}px)`;
            joystickHandle.style.top = `calc(50% + ${deltaY}px)`;
            
            joystick.moveX = deltaX / joystickMaxDistance;
            joystick.moveY = deltaY / joystickMaxDistance;
        }
        
        function resetJoystick() {
            joystick.active = false;
            joystick.moveX = 0;
            joystick.moveY = 0;
            joystick.touchId = null;
            
            joystickHandle.style.left = '50%';
            joystickHandle.style.top = '50%';
            joystickHandle.style.transform = 'translate(-50%, -50%)';
        }
        
        // Shield activation
        function activateShield() {
            if (!game.running) return;
            if (game.shieldCooldown > 0) return;
            
            game.shieldActive = getShieldDuration() * 60; // Convert to frames
            game.shieldCooldown = getShieldCooldown() * 60;
            
            // Visual feedback
            const btn = document.getElementById('shieldBtn');
            btn.classList.add('on-cooldown');
            
            showSpeechBubble(game.player.x, game.player.y, "–©–ò–¢ –ê–ö–¢–ò–í–ò–†–û–í–ê–ù!", false);
        }
        
        // Keyboard shield activation
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
            if (e.key === ' ') {
                activateShield();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        // –§—Ä–∞–∑—ã –∏–≥—Ä–æ–∫–∞
        const PLAYER_PHRASES = [
            "–Ø —É–∂–µ –∫—Ä–∞—Å–Ω—ã–π!",
            "–ï—â—ë –ø–æ—Å–∏–¥–∏–º, –Ω–æ—Ä–º–∞–ª—å–Ω–æ",
            "–ù–æ—Ä–º–∞–ª—å–Ω–æ, —Ç–µ—Ä–ø–∏–º–æ!"
        ];
        
        // –§—Ä–∞–∑—ã –≤—Ä–∞–≥–æ–≤
        const ENEMY_PHRASES = [
            "–¢—ã –±–ª*–¥—å, –¥*–ª–±–∞—ë–± –Ω–∞—Ö*–π?",
            "–Ø —É–∂–µ —Å–∏–Ω–∏–π!",
            "–ü–æ–≤—ã—Å—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É!",
            "–û–º–∞–π–≥–∞–¥"
        ];
        
        const FORMS = [
            { name: '–°—ã—Ä', color: '#ffff00', size: 12, targetTemp: 1000 },
            { name: '–ß', color: '#ffffff', size: 18, targetTemp: 5000 },
            { name: '–ë–∞—Ç—á', color: '#ffffaa', size: 20, targetTemp: 10000 },
            { name: '–î–æ–¥', color: '#ffa500', size: 22, targetTemp: 50000 },
            { name: '–ü—Ä–∞–¥–æ–¥', color: '#ff6b35', size: 24, targetTemp: 150000 },
            { name: '–ü—Ä–∞–ø—Ä–∞–¥–æ–¥', color: '#ff4500', size: 26, targetTemp: 400000 },
            { name: '–°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–¥–æ–¥', color: '#ff0000', size: 28, targetTemp: 800000 },
            { name: '–î–æ–¥–æ—Å', color: '#ff00ff', size: 30, targetTemp: 1500000 },
            { name: '–£–ª—å—Ç—Ä–∞–¥–æ–¥–æ—Å', color: '#00ffff', size: 32, targetTemp: 3000000 },
            { name: '–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞ –°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–ø—Ä–∞–¥–æ–¥–æ—Å', color: '#ffd700', size: 35, targetTemp: Infinity }
        ];
        
        const DIFFICULTY = [
            { enemies: 1, attackSpeed: 2000, projectileSpeed: 2, projectilesPerAttack: 1, damage: 3, patterns: ['aimed'], specialAttackChance: 0, enemyMoveSpeed: 0.01 },
            { enemies: 1, attackSpeed: 1600, projectileSpeed: 2.5, projectilesPerAttack: 2, damage: 5, patterns: ['aimed', 'spread3'], specialAttackChance: 0.1, enemyMoveSpeed: 0.015 },
            { enemies: 2, attackSpeed: 1400, projectileSpeed: 3, projectilesPerAttack: 2, damage: 7, patterns: ['aimed', 'spread3', 'circle'], specialAttackChance: 0.15, enemyMoveSpeed: 0.02 },
            { enemies: 2, attackSpeed: 1200, projectileSpeed: 3.5, projectilesPerAttack: 3, damage: 8, patterns: ['aimed', 'spread5', 'circle', 'wave'], specialAttackChance: 0.2, enemyMoveSpeed: 0.025 },
            { enemies: 3, attackSpeed: 1000, projectileSpeed: 4, projectilesPerAttack: 3, damage: 10, patterns: ['spread5', 'circle', 'wave', 'spiral'], specialAttackChance: 0.25, enemyMoveSpeed: 0.03 },
            { enemies: 3, attackSpeed: 800, projectileSpeed: 4.5, projectilesPerAttack: 4, damage: 12, patterns: ['spread5', 'circle', 'wave', 'spiral', 'cross'], specialAttackChance: 0.3, enemyMoveSpeed: 0.035 },
            { enemies: 4, attackSpeed: 600, projectileSpeed: 5, projectilesPerAttack: 4, damage: 15, patterns: ['circle', 'wave', 'spiral', 'cross', 'burst'], specialAttackChance: 0.35, enemyMoveSpeed: 0.04 },
            { enemies: 4, attackSpeed: 450, projectileSpeed: 5.5, projectilesPerAttack: 5, damage: 18, patterns: ['spiral', 'cross', 'burst', 'chaos'], specialAttackChance: 0.4, enemyMoveSpeed: 0.045 },
            { enemies: 5, attackSpeed: 300, projectileSpeed: 6, projectilesPerAttack: 6, damage: 21, patterns: ['chaos', 'apocalypse'], specialAttackChance: 0.5, enemyMoveSpeed: 0.05 }
        ];
        
        const ENEMY_TYPES = [
            { name: '–î–æ–¥', emoji: 'üî•', color: '#8b4513' },
            { name: '–ü—Ä–∞–¥–æ–¥', emoji: 'üë¥üî•', color: '#654321' },
            { name: '–ü—Ä–∞–ø—Ä–∞–¥–æ–¥', emoji: 'üë¥üë¥', color: '#4a3520' },
            { name: '–°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–¥–æ–¥', emoji: '‚≠êüë¥', color: '#3d2914' },
            { name: '–î–æ–¥–æ—Å', emoji: 'ü¶§', color: '#2d1f0f' },
            { name: '–£–ª—å—Ç—Ä–∞–¥–æ–¥–æ—Å', emoji: 'üíÄü¶§', color: '#1a1209' },
            { name: '–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞', emoji: 'üåüüíÄ', color: '#0a0604' },
            { name: '–ë–û–°–° –ë–ê–ù–ò', emoji: 'üëëüî•', color: '#000000' },
            { name: '–ë–û–ì –ü–ê–†–ê', emoji: '‚ò†Ô∏èüëë', color: '#220000' }
        ];
        
        let game = {
            running: false,
            player: null,
            temperature: 0,
            enemies: [],
            projectiles: [],
            particles: [],
            keys: {},
            tempRate: 10,
            screenShake: 0,
            lastPlayerPhrase: 0,
            lastEnemyPhrase: 0,
            sessionCoins: 0,
            shieldActive: 0,
            shieldCooldown: 0
        };
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ —Ä–µ—á–µ–≤–æ–≥–æ –ø—É–∑—ã—Ä—è
        function showSpeechBubble(x, y, text, isEnemy = false) {
            const container = document.getElementById('speechContainer');
            const bubble = document.createElement('div');
            bubble.className = `speech-bubble ${isEnemy ? 'enemy' : ''}`;
            bubble.textContent = text;
            
            const canvasRect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;
            
            bubble.style.left = `${x / scaleX - 30}px`;
            bubble.style.top = `${y / scaleY - 50}px`;
            
            container.appendChild(bubble);
            
            setTimeout(() => {
                bubble.style.animation = 'bubbleFade 0.5s ease-out forwards';
                setTimeout(() => bubble.remove(), 500);
            }, 2000);
        }
        
        // Coin popup
        function showCoinPopup(x, y, amount) {
            const container = document.getElementById('coinContainer');
            const popup = document.createElement('div');
            popup.className = 'coin-popup';
            popup.textContent = `+${amount} üí∞`;
            
            const canvasRect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvasRect.width;
            
            popup.style.left = `${x / scaleX}px`;
            popup.style.top = `${y / scaleX}px`;
            
            container.appendChild(popup);
            
            setTimeout(() => popup.remove(), 1000);
        }
        
        function playerSpeak() {
            if (!game.running) return;
            const phrase = PLAYER_PHRASES[Math.floor(Math.random() * PLAYER_PHRASES.length)];
            showSpeechBubble(game.player.x, game.player.y, phrase, false);
        }
        
        function enemySpeak(enemy) {
            if (!game.running) return;
            const phrase = ENEMY_PHRASES[Math.floor(Math.random() * ENEMY_PHRASES.length)];
            showSpeechBubble(enemy.x, enemy.y, phrase, true);
        }
        
        function goToMenu() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('startScreen').classList.remove('hidden');
            updateShopUI();
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            document.getElementById('gameScreen').classList.add('flex');
            
            document.getElementById('speechContainer').innerHTML = '';
            document.getElementById('coinContainer').innerHTML = '';
            
            const maxHP = getMaxHealth();
            
            game = {
                running: true,
                player: { x: 100, y: 250, vx: 0, vy: 0, health: maxHP, maxHealth: maxHP, formIndex: 0, invincible: 0 },
                temperature: 0,
                enemies: [],
                projectiles: [],
                particles: [],
                keys: {},
                tempRate: 50,
                screenShake: 0,
                lastPlayerPhrase: Date.now(),
                lastEnemyPhrase: Date.now(),
                sessionCoins: 0,
                shieldActive: 0,
                shieldCooldown: 0
            };
            
            // Update shield button
            document.getElementById('shieldBtn').classList.remove('on-cooldown');
            
            spawnEnemies();
            updateUI();
            gameLoop();
            
            setTimeout(() => playerSpeak(), 1000);
        }
        
        function spawnEnemies() {
            game.enemies = [];
            const diff = DIFFICULTY[game.player.formIndex];
            const enemyType = ENEMY_TYPES[Math.min(game.player.formIndex, ENEMY_TYPES.length - 1)];
            
            for (let i = 0; i < diff.enemies; i++) {
                game.enemies.push({
                    x: canvas.width - 80,
                    y: 100 + (i * (canvas.height - 200) / Math.max(1, diff.enemies - 1)),
                    targetY: 100 + Math.random() * (canvas.height - 200),
                    lastAttack: Date.now() + i * 500,
                    type: enemyType,
                    size: 35 + game.player.formIndex * 3,
                    angle: 0
                });
            }
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            startGame();
        }
        
        function updateUI() {
            const form = FORMS[game.player.formIndex];
            document.getElementById('playerForm').textContent = form.name;
            document.getElementById('temperature').textContent = Math.floor(game.temperature).toLocaleString();
            document.getElementById('health').textContent = Math.max(0, Math.floor(game.player.health));
            document.getElementById('coins').textContent = game.sessionCoins;
            
            // Shield status
            const shieldStatus = document.getElementById('shieldStatus');
            const shieldBtn = document.getElementById('shieldBtn');
            if (game.shieldActive > 0) {
                shieldStatus.textContent = `${Math.ceil(game.shieldActive / 60)}—Å`;
                shieldStatus.className = 'text-green-300';
            } else if (game.shieldCooldown > 0) {
                shieldStatus.textContent = `${Math.ceil(game.shieldCooldown / 60)}—Å`;
                shieldStatus.className = 'text-gray-500';
                shieldBtn.classList.add('on-cooldown');
            } else {
                shieldStatus.textContent = '–ì–æ—Ç–æ–≤';
                shieldStatus.className = 'text-cyan-300';
                shieldBtn.classList.remove('on-cooldown');
            }
            
            const enemyType = ENEMY_TYPES[Math.min(game.player.formIndex, ENEMY_TYPES.length - 1)];
            const diff = DIFFICULTY[game.player.formIndex];
            document.getElementById('enemyInfo').textContent = `–í—Ä–∞–≥–∏: ${diff.enemies}x ${enemyType.emoji} ${enemyType.name}`;
            
            const progress = (game.temperature / form.targetTemp) * 100;
            document.getElementById('tempBar').style.width = Math.min(100, progress) + '%';
            document.getElementById('nextForm').textContent = form.targetTemp === Infinity ? '‚àû' : form.targetTemp.toLocaleString() + '¬∞C';
            
            const stars = '‚òÖ'.repeat(game.player.formIndex + 1) + '‚òÜ'.repeat(8 - game.player.formIndex);
            document.getElementById('difficultyInfo').textContent = `–°–ª–æ–∂–Ω–æ—Å—Ç—å: ${stars}`;
        }
        
        function gameLoop() {
            if (!game.running) return;
            
            update();
            render();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        function createAttackPattern(enemy, pattern, diff) {
            const angle = Math.atan2(game.player.y - enemy.y, game.player.x - enemy.x);
            
            switch(pattern) {
                case 'aimed':
                    game.projectiles.push(createProjectile(enemy.x, enemy.y, angle, diff));
                    break;
                case 'spread3':
                    for (let i = -1; i <= 1; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + i * 0.3, diff));
                    }
                    break;
                case 'spread5':
                    for (let i = -2; i <= 2; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + i * 0.25, diff));
                    }
                    break;
                case 'circle':
                    for (let i = 0; i < 8; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 8) * i, diff));
                    }
                    break;
                case 'wave':
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (game.running) {
                                game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + Math.sin(Date.now() / 100) * 0.5, diff));
                            }
                        }, i * 100);
                    }
                    break;
                case 'spiral':
                    enemy.angle = (enemy.angle || 0) + 0.5;
                    for (let i = 0; i < 3; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, enemy.angle + (Math.PI * 2 / 3) * i, diff));
                    }
                    break;
                case 'cross':
                    for (let i = 0; i < 4; i++) {
                        const crossAngle = (Math.PI / 2) * i;
                        for (let j = 0; j < 3; j++) {
                            setTimeout(() => {
                                if (game.running) {
                                    game.projectiles.push(createProjectile(enemy.x, enemy.y, crossAngle, diff));
                                }
                            }, j * 150);
                        }
                    }
                    break;
                case 'burst':
                    for (let i = 0; i < 12; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 12) * i, diff));
                    }
                    setTimeout(() => {
                        if (game.running) {
                            for (let i = 0; i < 12; i++) {
                                game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 12) * i + 0.26, diff));
                            }
                        }
                    }, 200);
                    break;
                case 'chaos':
                    for (let i = 0; i < 8; i++) {
                        const chaosAngle = Math.random() * Math.PI * 2;
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, chaosAngle, diff));
                    }
                    break;
                case 'apocalypse':
                    for (let i = 0; i < 16; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 16) * i, diff));
                    }
                    for (let wave = 1; wave <= 3; wave++) {
                        setTimeout(() => {
                            if (game.running) {
                                for (let i = 0; i < 16; i++) {
                                    game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 16) * i + wave * 0.2, diff));
                                }
                            }
                        }, wave * 150);
                    }
                    break;
            }
        }
        
        function createProjectile(x, y, angle, diff) {
            return {
                x: x,
                y: y,
                vx: Math.cos(angle) * diff.projectileSpeed,
                vy: Math.sin(angle) * diff.projectileSpeed,
                size: 6 + game.player.formIndex,
                damage: diff.damage
            };
        }
        
        function update() {
            const form = FORMS[game.player.formIndex];
            const diff = DIFFICULTY[game.player.formIndex];
            
            // Shield timers
            if (game.shieldActive > 0) game.shieldActive--;
            if (game.shieldCooldown > 0) game.shieldCooldown--;
            
            // Player movement
            const speed = 5 + game.player.formIndex * 0.3;
            
            let inputX = 0;
            let inputY = 0;
            
            if (game.keys['w'] || game.keys['arrowup']) inputY = -1;
            else if (game.keys['s'] || game.keys['arrowdown']) inputY = 1;
            
            if (game.keys['a'] || game.keys['arrowleft']) inputX = -1;
            else if (game.keys['d'] || game.keys['arrowright']) inputX = 1;
            
            if (joystick.active || Math.abs(joystick.moveX) > 0.1 || Math.abs(joystick.moveY) > 0.1) {
                inputX = joystick.moveX;
                inputY = joystick.moveY;
            }
            
            if (Math.abs(inputX) > 0.1) {
                game.player.vx = inputX * speed;
            } else {
                game.player.vx *= 0.85;
            }
            
            if (Math.abs(inputY) > 0.1) {
                game.player.vy = inputY * speed;
            } else {
                game.player.vy *= 0.85;
            }
            
            game.player.x += game.player.vx;
            game.player.y += game.player.vy;
            
            game.player.x = Math.max(form.size, Math.min(canvas.width - form.size - 150, game.player.x));
            game.player.y = Math.max(form.size, Math.min(canvas.height - form.size, game.player.y));
            
            // Increase temperature with XP multiplier
            const xpBonus = getXPMultiplier();
            game.temperature += ((game.tempRate + game.player.formIndex * 25) / 60) * xpBonus;
            
            // Earn coins over time
            if (Math.random() < 0.02 + game.player.formIndex * 0.01) {
                const coinAmount = 1 + game.player.formIndex;
                game.sessionCoins += coinAmount;
                showCoinPopup(game.player.x + (Math.random() - 0.5) * 30, game.player.y - 20, coinAmount);
            }
            
            if (Date.now() - game.lastPlayerPhrase > 3000 + Math.random() * 3000) {
                game.lastPlayerPhrase = Date.now();
                playerSpeak();
            }
            
            // Check for transformation
            if (game.temperature >= form.targetTemp) {
                if (game.player.formIndex < FORMS.length - 1) {
                    game.player.formIndex++;
                    game.player.invincible = 180;
                    game.player.health = Math.min(game.player.maxHealth, game.player.health + 30);
                    game.tempRate *= 1.8;
                    
                    // Bonus coins for transformation
                    const bonusCoins = 20 + game.player.formIndex * 15;
                    game.sessionCoins += bonusCoins;
                    showCoinPopup(game.player.x, game.player.y - 40, bonusCoins);
                    
                    spawnEnemies();
                    
                    for (let i = 0; i < 50; i++) {
                        game.particles.push({
                            x: game.player.x,
                            y: game.player.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 90,
                            color: FORMS[game.player.formIndex].color
                        });
                    }
                    
                    game.screenShake = 20;
                    
                    setTimeout(() => {
                        if (game.running) {
                            showSpeechBubble(game.player.x, game.player.y, "–Ø –≠–í–û–õ–Æ–¶–ò–û–ù–ò–†–£–Æ!", false);
                        }
                    }, 100);
                    
                    if (game.player.formIndex === FORMS.length - 1) {
                        setTimeout(() => {
                            game.running = false;
                            game.sessionCoins += 500; // Victory bonus
                            saveData.coins += game.sessionCoins;
                            saveSave();
                            document.getElementById('gameScreen').classList.add('hidden');
                            document.getElementById('victoryScreen').classList.remove('hidden');
                        }, 2000);
                    }
                }
            }
            
            // Enemy behavior
            game.enemies.forEach((enemy, idx) => {
                if (Math.abs(enemy.y - enemy.targetY) < 10) {
                    enemy.targetY = 50 + Math.random() * (canvas.height - 100);
                }
                enemy.y += (enemy.targetY - enemy.y) * diff.enemyMoveSpeed;
                
                if (game.player.formIndex >= 4) {
                    enemy.x = canvas.width - 80 + Math.sin(Date.now() / 500 + idx) * 30;
                }
                
                if (Date.now() - enemy.lastAttack > diff.attackSpeed) {
                    enemy.lastAttack = Date.now();
                    
                    const patterns = diff.patterns;
                    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                    createAttackPattern(enemy, pattern, diff);
                    
                    if (Math.random() < 0.15 && Date.now() - game.lastEnemyPhrase > 2000) {
                        game.lastEnemyPhrase = Date.now();
                        enemySpeak(enemy);
                    }
                    
                    if (Math.random() < diff.specialAttackChance) {
                        setTimeout(() => {
                            if (game.running) {
                                const specialPattern = patterns[patterns.length - 1];
                                createAttackPattern(enemy, specialPattern, diff);
                            }
                        }, 300);
                    }
                }
            });
            
            // Update projectiles
            game.projectiles = game.projectiles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Check collision with player (ignore if shield active)
                if (game.player.invincible <= 0 && game.shieldActive <= 0) {
                    const dx = p.x - game.player.x;
                    const dy = p.y - game.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < form.size + p.size) {
                        game.player.health -= p.damage;
                        game.player.invincible = 20;
                        game.screenShake = 10;
                        
                        if (Math.random() < 0.25) {
                            const hitPhrases = ["–ê–π, –±–ª*—Ç—å!", "–°—É–∫–∞!", "–ë–æ–ª—å–Ω–æ!", "–ü*–∑–¥–µ—Ü!"];
                            showSpeechBubble(game.player.x, game.player.y, hitPhrases[Math.floor(Math.random() * hitPhrases.length)], false);
                        }
                        
                        for (let i = 0; i < 15; i++) {
                            game.particles.push({
                                x: game.player.x,
                                y: game.player.y,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                life: 30,
                                color: '#ff0000'
                            });
                        }
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                        return false;
                    }
                } else if (game.shieldActive > 0) {
                    // Shield deflects projectiles
                    const dx = p.x - game.player.x;
                    const dy = p.y - game.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < form.size + 20) {
                        // Deflect particle effect
                        for (let i = 0; i < 5; i++) {
                            game.particles.push({
                                x: p.x,
                                y: p.y,
                                vx: (Math.random() - 0.5) * 6,
                                vy: (Math.random() - 0.5) * 6,
                                life: 20,
                                color: '#00bfff'
                            });
                        }
                        return false;
                    }
                }
                
                return p.x > -50 && p.x < canvas.width + 50 && p.y > -50 && p.y < canvas.height + 50;
            });
            
            // Update particles
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                return p.life > 0;
            });
            
            if (game.player.invincible > 0) game.player.invincible--;
            if (game.screenShake > 0) game.screenShake--;
        }
        
        function render() {
            ctx.save();
            if (game.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }
            
            // Background
            const heat = Math.min(1, game.temperature / 1000000);
            const formHeat = game.player.formIndex / 8;
            ctx.fillStyle = `rgb(${40 + (heat + formHeat) * 80}, ${20 - heat * 15}, ${20 - heat * 15})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = `rgba(255, 0, 0, ${0.05 + formHeat * 0.1})`;
            ctx.fillRect(canvas.width - 200, 0, 200, canvas.height);
            
            // Steam effect
            const steamCount = 3 + game.player.formIndex * 2;
            for (let i = 0; i < steamCount; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.02 + heat * 0.08})`;
                ctx.beginPath();
                ctx.arc(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    15 + Math.random() * 40,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Draw particles
            game.particles.forEach(p => {
                ctx.globalAlpha = p.life / 90;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 + (90 - p.life) / 20, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw projectiles
            game.projectiles.forEach(p => {
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 10;
                
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            });
            
            // Draw enemies
            game.enemies.forEach((enemy, idx) => {
                const pulseSize = Math.sin(Date.now() / 200 + idx) * 3;
                
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20 + game.player.formIndex * 3;
                
                ctx.fillStyle = enemy.type.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size + pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 100, 0, 0.5)`;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                ctx.font = `${18 + game.player.formIndex * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enemy.type.emoji, enemy.x, enemy.y);
            });
            
            // Draw player
            const form = FORMS[game.player.formIndex];
            
            if (game.player.invincible <= 0 || Math.floor(game.player.invincible / 4) % 2 === 0) {
                // Shield effect
                if (game.shieldActive > 0) {
                    ctx.shadowColor = '#00bfff';
                    ctx.shadowBlur = 30;
                    ctx.strokeStyle = '#00bfff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, form.size + 15 + Math.sin(Date.now() / 50) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner shield
                    ctx.strokeStyle = 'rgba(0, 191, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, form.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowColor = form.color;
                ctx.shadowBlur = 20 + game.player.formIndex * 5;
                
                if (game.player.formIndex >= 3) {
                    ctx.strokeStyle = form.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, form.size + 8 + Math.sin(Date.now() / 100) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = form.color;
                ctx.beginPath();
                ctx.arc(game.player.x, game.player.y, form.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.min(form.size - 4, 12)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const displayName = form.name.length > 8 ? form.name.substring(0, 7) + '..' : form.name;
                ctx.fillText(displayName, game.player.x, game.player.y);
            }
            
            // Health bar
            ctx.fillStyle = '#333';
            ctx.fillRect(10, 10, 150, 15);
            const healthColor = game.player.health > game.player.maxHealth * 0.5 ? '#00ff00' : game.player.health > game.player.maxHealth * 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillStyle = healthColor;
            ctx.fillRect(10, 10, Math.max(0, (game.player.health / game.player.maxHealth) * 150), 15);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 150, 15);
            
            // HP text
            ctx.fillStyle = '#fff';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(game.player.health)}/${game.player.maxHealth}`, 85, 18);
            
            // Temperature display
            ctx.textAlign = 'left';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText(`üå°Ô∏è ${Math.floor(game.temperature).toLocaleString()}¬∞C`, 10, 42);
            
            // Level/Form indicator
            ctx.fillStyle = form.color;
            ctx.fillText(`${form.name}`, 10, 58);
            
            // Coins display
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`üí∞ ${game.sessionCoins}`, 10, 74);
            
            // Shield cooldown indicator
            if (game.shieldCooldown > 0 && game.shieldActive <= 0) {
                ctx.fillStyle = '#888';
                ctx.fillText(`üõ°Ô∏è ${Math.ceil(game.shieldCooldown / 60)}—Å`, canvas.width - 100, 20);
            } else if (game.shieldActive > 0) {
                ctx.fillStyle = '#00bfff';
                ctx.fillText(`üõ°Ô∏è ${Math.ceil(game.shieldActive / 60)}—Å`, canvas.width - 100, 20);
            } else {
                ctx.fillStyle = '#00ff00';
                ctx.fillText(`üõ°Ô∏è –ì–û–¢–û–í`, canvas.width - 100, 20);
            }
            
            ctx.restore();
        }
        
        function gameOver() {
            game.running = false;
            
            showSpeechBubble(game.player.x, game.player.y, "–Ø –°–ì–û–†–ï–õ!!!", false);
            
            // Save coins
            saveData.coins += game.sessionCoins;
            saveSave();
            
            setTimeout(() => {
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
                document.getElementById('finalForm').textContent = FORMS[game.player.formIndex].name;
                document.getElementById('finalTemp').textContent = Math.floor(game.temperature).toLocaleString();
                document.getElementById('earnedCoins').textContent = game.sessionCoins;
                document.getElementById('finalLevel').textContent = `${game.player.formIndex + 1}/9`;
            }, 500);
        }
        
        // Steam effects
        function createSteam() {
            if (!game.running) return;
            
            const container = document.getElementById('steamContainer');
            const steam = document.createElement('div');
            steam.className = 'steam';
            steam.style.left = Math.random() * 100 + '%';
            steam.style.bottom = '0';
            steam.style.animationDelay = Math.random() * 2 + 's';
            container.appendChild(steam);
            
            setTimeout(() => steam.remove(), 2000);
        }
        
        setInterval(createSteam, 300);
        
        // Load save on start
        loadSave();
        
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                // Don't prevent default for buttons
            }
        }, { passive: true });
    </script>
</body>
</html>
