<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ë–∞–Ω—è –î–æ–¥–æ–≤ üî•</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            font-family: 'Press Start 2P', cursive;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: linear-gradient(135deg, #1a0000 0%, #4a1010 50%, #1a0000 100%);
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameCanvas {
            border: 4px solid #ff6b35;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 107, 53, 0.5);
            max-width: 100%;
            height: auto;
        }
        
        .steam {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: steamRise 2s infinite;
        }
        
        @keyframes steamRise {
            0% { transform: translateY(0) scale(1); opacity: 0.5; }
            100% { transform: translateY(-100px) scale(2); opacity: 0; }
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .glow {
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
        }
        
        .shake {
            animation: shake 0.3s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .speech-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 10px;
            color: #333;
            max-width: 150px;
            animation: bubblePop 0.3s ease-out;
            pointer-events: none;
            z-index: 100;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 20px;
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.95) transparent transparent;
        }
        
        .speech-bubble.enemy {
            background: rgba(255, 100, 100, 0.95);
            color: #500;
        }
        
        .speech-bubble.enemy::after {
            border-color: rgba(255, 100, 100, 0.95) transparent transparent;
        }
        
        @keyframes bubblePop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes bubbleFade {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        /* Joystick Styles */
        #joystickContainer {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 1000;
            display: none;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 107, 53, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.3);
        }
        
        #joystickHandle {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #ff6b35, #ff4500);
            border: 2px solid #fff;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.7);
        }
        
        #mobileControls {
            display: none;
        }
        
        /* Show joystick on touch devices */
        @media (pointer: coarse) {
            #joystickContainer {
                display: block;
            }
            #mobileControls {
                display: block;
            }
            #gameCanvas {
                max-height: 60vh;
            }
        }
        
        /* Fullscreen button */
        #fullscreenBtn {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 107, 53, 0.8);
            border: none;
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 10px;
            display: none;
        }
        
        @media (pointer: coarse) {
            #fullscreenBtn {
                display: block;
            }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <!-- Fullscreen button for mobile -->
    <button id="fullscreenBtn" onclick="toggleFullscreen()">‚õ∂ –ü–û–õ–ù–´–ô –≠–ö–†–ê–ù</button>

    <!-- Start Screen -->
    <div id="startScreen" class="text-center">
        <h1 class="text-3xl md:text-5xl text-orange-500 mb-8 glow">üî• –ë–ê–ù–Ø –î–û–î–û–í üî•</h1>
        <p class="text-white text-xs md:text-sm mb-4">–¢—ã - "–ß". –ó–∞–π–¥–∏ –≤ –±–∞–Ω—é –∏ —Å—Ç–∞–Ω—å –ª–µ–≥–µ–Ω–¥–æ–π!</p>
        <p class="text-yellow-300 text-xs mb-2">–ü–ö: WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏</p>
        <p class="text-yellow-300 text-xs mb-6" id="mobileControls">üì± –¢–µ–ª–µ—Ñ–æ–Ω: –î–∂–æ–π—Å—Ç–∏–∫ —Å–ª–µ–≤–∞</p>
        <button onclick="startGame()" class="bg-orange-600 hover:bg-orange-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
            –í–û–ô–¢–ò –í –ë–ê–ù–Æ
        </button>
        <div class="mt-8 text-xs text-gray-400">
            <p>‚ö†Ô∏è –° –∫–∞–∂–¥–æ–π —Ñ–æ—Ä–º–æ–π –°–õ–û–ñ–ù–ï–ï!</p>
            <p class="mt-2">–ë–æ–ª—å—à–µ –≤—Ä–∞–≥–æ–≤, –∞—Ç–∞–∫ –∏ —Ö–∞–æ—Å–∞!</p>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="hidden flex-col items-center">
        <div class="flex justify-between w-full max-w-2xl mb-4 px-2 flex-wrap gap-2">
            <div class="text-white text-xs">
                <span class="text-orange-400">–§–û–†–ú–ê:</span> 
                <span id="playerForm" class="text-yellow-300">–ß</span>
            </div>
            <div class="text-white text-xs">
                <span class="text-red-400">üå°Ô∏è</span> 
                <span id="temperature" class="text-red-300">0</span>¬∞C
            </div>
            <div class="text-white text-xs">
                <span class="text-green-400">‚ù§Ô∏è</span> 
                <span id="health" class="text-green-300">100</span>
            </div>
            <div class="text-white text-xs">
                <span class="text-purple-400">LVL:</span> 
                <span id="level" class="text-purple-300">1</span>
            </div>
        </div>
        
        <div class="relative">
            <canvas id="gameCanvas" width="700" height="500"></canvas>
            <div id="steamContainer" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
            <div id="speechContainer" class="absolute inset-0 pointer-events-none overflow-hidden"></div>
        </div>
        
        <div class="mt-4 text-center">
            <p class="text-orange-300 text-xs" id="enemyInfo">–ì–æ—Ç–æ–≤—å—Å—è –∫ –±–æ—é!</p>
            <div class="w-full bg-gray-700 rounded-full h-4 mt-2" style="width: 300px; max-width: 90vw;">
                <div id="tempBar" class="bg-gradient-to-r from-orange-500 to-red-600 h-4 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-xs mt-1">–î–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: <span id="nextForm">1000¬∞C</span></p>
            <p class="text-red-400 text-xs mt-1" id="difficultyInfo">–°–ª–æ–∂–Ω–æ—Å—Ç—å: ‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ</p>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden text-center">
        <h2 class="text-4xl text-red-500 mb-4 glow">üíÄ –°–ì–û–†–ï–õ! üíÄ</h2>
        <p class="text-white text-sm mb-2">–î–æ—Å—Ç–∏–≥–Ω—É—Ç–∞—è —Ñ–æ—Ä–º–∞: <span id="finalForm" class="text-yellow-300"></span></p>
        <p class="text-orange-300 text-sm mb-2">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: <span id="finalTemp"></span>¬∞C</p>
        <p class="text-purple-300 text-sm mb-6">–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏: <span id="finalLevel"></span></p>
        <button onclick="restartGame()" class="bg-orange-600 hover:bg-orange-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
            –°–ù–û–í–ê –í –ë–ê–ù–Æ
        </button>
    </div>

    <!-- Victory Screen -->
    <div id="victoryScreen" class="hidden text-center">
        <h2 class="text-3xl text-yellow-400 mb-4 glow pulse">üëë –õ–ï–ì–ï–ù–î–ê –ë–ê–ù–ò! üëë</h2>
        <p class="text-white text-sm mb-2">–¢—ã —Å—Ç–∞–ª:</p>
        <p class="text-2xl text-orange-400 mb-6 glow">–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞ –°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–ø—Ä–∞–¥–æ–¥–æ—Å!</p>
        <p class="text-green-300 text-sm mb-6">–¢—ã –ø–æ–±–µ–¥–∏–ª –í–°–ï —É—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏!</p>
        <button onclick="restartGame()" class="bg-yellow-600 hover:bg-yellow-700 text-white px-8 py-4 rounded-lg text-sm transition-all hover:scale-110 active:scale-95">
            –ù–ê–ß–ê–¢–¨ –ó–ê–ù–û–í–û
        </button>
    </div>

    <!-- Virtual Joystick -->
    <div id="joystickContainer">
        <div id="joystickBase"></div>
        <div id="joystickHandle"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Joystick variables
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const joystickBase = document.getElementById('joystickBase');
        
        let joystick = {
            active: false,
            startX: 0,
            startY: 0,
            moveX: 0,
            moveY: 0,
            touchId: null
        };
        
        const joystickMaxDistance = 45;
        
        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // Joystick touch events
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            joystick.active = true;
            joystick.touchId = touch.identifier;
            
            const rect = joystickBase.getBoundingClientRect();
            joystick.startX = rect.left + rect.width / 2;
            joystick.startY = rect.top + rect.height / 2;
            
            updateJoystickPosition(touch.clientX, touch.clientY);
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!joystick.active) return;
            
            for (let i = 0; i < e.touches.length; i++) {
                if (e.touches[i].identifier === joystick.touchId) {
                    e.preventDefault();
                    updateJoystickPosition(e.touches[i].clientX, e.touches[i].clientY);
                    break;
                }
            }
        }, { passive: false });
        
        document.addEventListener('touchend', (e) => {
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystick.touchId) {
                    resetJoystick();
                    break;
                }
            }
        });
        
        document.addEventListener('touchcancel', (e) => {
            resetJoystick();
        });
        
        function updateJoystickPosition(touchX, touchY) {
            let deltaX = touchX - joystick.startX;
            let deltaY = touchY - joystick.startY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > joystickMaxDistance) {
                deltaX = (deltaX / distance) * joystickMaxDistance;
                deltaY = (deltaY / distance) * joystickMaxDistance;
            }
            
            joystickHandle.style.left = `calc(50% + ${deltaX}px)`;
            joystickHandle.style.top = `calc(50% + ${deltaY}px)`;
            
            // Normalize to -1 to 1 range
            joystick.moveX = deltaX / joystickMaxDistance;
            joystick.moveY = deltaY / joystickMaxDistance;
        }
        
        function resetJoystick() {
            joystick.active = false;
            joystick.moveX = 0;
            joystick.moveY = 0;
            joystick.touchId = null;
            
            joystickHandle.style.left = '50%';
            joystickHandle.style.top = '50%';
            joystickHandle.style.transform = 'translate(-50%, -50%)';
        }
        
        // –§—Ä–∞–∑—ã –∏–≥—Ä–æ–∫–∞
        const PLAYER_PHRASES = [
            "–Ø —É–∂–µ –∫—Ä–∞—Å–Ω—ã–π!",
            "–ï—â—ë –ø–æ—Å–∏–¥–∏–º, –Ω–æ—Ä–º–∞–ª—å–Ω–æ",
            "–ù–æ—Ä–º–∞–ª—å–Ω–æ, —Ç–µ—Ä–ø–∏–º–æ!"
        ];
        
        // –§—Ä–∞–∑—ã –≤—Ä–∞–≥–æ–≤
        const ENEMY_PHRASES = [
            "–¢—ã –±–ª*–¥—å, –¥*–ª–±–∞—ë–± –Ω–∞—Ö*–π?",
            "–Ø —É–∂–µ —Å–∏–Ω–∏–π!",
            "–ü–æ–≤—ã—Å—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É!"
        ];
        
        const FORMS = [
            { name: '–°—ã—Ä', color: '#ffff00', size: 12, targetTemp: 1000 },
            { name: '–ß', color: '#ffffff', size: 18, targetTemp: 5000 },
            { name: '–ë–∞—Ç—á', color: '#ffffaa', size: 20, targetTemp: 10000 },
            { name: '–î–æ–¥', color: '#ffa500', size: 22, targetTemp: 50000 },
            { name: '–ü—Ä–∞–¥–æ–¥', color: '#ff6b35', size: 24, targetTemp: 150000 },
            { name: '–ü—Ä–∞–ø—Ä–∞–¥–æ–¥', color: '#ff4500', size: 26, targetTemp: 400000 },
            { name: '–°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–¥–æ–¥', color: '#ff0000', size: 28, targetTemp: 800000 },
            { name: '–î–æ–¥–æ—Å', color: '#ff00ff', size: 30, targetTemp: 1500000 },
            { name: '–£–ª—å—Ç—Ä–∞–¥–æ–¥–æ—Å', color: '#00ffff', size: 32, targetTemp: 3000000 },
            { name: '–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞ –°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–ø—Ä–∞–¥–æ–¥–æ—Å', color: '#ffd700', size: 35, targetTemp: Infinity }
        ];
        
        // –°–ª–æ–∂–Ω–æ—Å—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è —Å –∫–∞–∂–¥–æ–π —Ñ–æ—Ä–º–æ–π
        const DIFFICULTY = [
            { // –£—Ä–æ–≤–µ–Ω—å 1 - –ß
                enemies: 1,
                attackSpeed: 2000,
                projectileSpeed: 2,
                projectilesPerAttack: 1,
                damage: 8,
                patterns: ['aimed'],
                specialAttackChance: 0,
                enemyMoveSpeed: 0.01
            },
            { // –£—Ä–æ–≤–µ–Ω—å 2 - –ë–∞—Ç—á
                enemies: 1,
                attackSpeed: 1600,
                projectileSpeed: 2.5,
                projectilesPerAttack: 2,
                damage: 10,
                patterns: ['aimed', 'spread3'],
                specialAttackChance: 0.1,
                enemyMoveSpeed: 0.015
            },
            { // –£—Ä–æ–≤–µ–Ω—å 3 - –î–æ–¥
                enemies: 2,
                attackSpeed: 1400,
                projectileSpeed: 3,
                projectilesPerAttack: 2,
                damage: 12,
                patterns: ['aimed', 'spread3', 'circle'],
                specialAttackChance: 0.15,
                enemyMoveSpeed: 0.02
            },
            { // –£—Ä–æ–≤–µ–Ω—å 4 - –ü—Ä–∞–¥–æ–¥
                enemies: 2,
                attackSpeed: 1200,
                projectileSpeed: 3.5,
                projectilesPerAttack: 3,
                damage: 14,
                patterns: ['aimed', 'spread5', 'circle', 'wave'],
                specialAttackChance: 0.2,
                enemyMoveSpeed: 0.025
            },
            { // –£—Ä–æ–≤–µ–Ω—å 5 - –ü—Ä–∞–ø—Ä–∞–¥–æ–¥
                enemies: 3,
                attackSpeed: 1000,
                projectileSpeed: 4,
                projectilesPerAttack: 3,
                damage: 16,
                patterns: ['spread5', 'circle', 'wave', 'spiral'],
                specialAttackChance: 0.25,
                enemyMoveSpeed: 0.03
            },
            { // –£—Ä–æ–≤–µ–Ω—å 6 - –°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–¥–æ–¥
                enemies: 3,
                attackSpeed: 800,
                projectileSpeed: 4.5,
                projectilesPerAttack: 4,
                damage: 18,
                patterns: ['spread5', 'circle', 'wave', 'spiral', 'cross'],
                specialAttackChance: 0.3,
                enemyMoveSpeed: 0.035
            },
            { // –£—Ä–æ–≤–µ–Ω—å 7 - –î–æ–¥–æ—Å
                enemies: 4,
                attackSpeed: 600,
                projectileSpeed: 5,
                projectilesPerAttack: 4,
                damage: 20,
                patterns: ['circle', 'wave', 'spiral', 'cross', 'burst'],
                specialAttackChance: 0.35,
                enemyMoveSpeed: 0.04
            },
            { // –£—Ä–æ–≤–µ–Ω—å 8 - –£–ª—å—Ç—Ä–∞–¥–æ–¥–æ—Å
                enemies: 4,
                attackSpeed: 450,
                projectileSpeed: 5.5,
                projectilesPerAttack: 5,
                damage: 25,
                patterns: ['spiral', 'cross', 'burst', 'chaos'],
                specialAttackChance: 0.4,
                enemyMoveSpeed: 0.045
            },
            { // –£—Ä–æ–≤–µ–Ω—å 9 - –§–ò–ù–ê–õ
                enemies: 5,
                attackSpeed: 300,
                projectileSpeed: 6,
                projectilesPerAttack: 6,
                damage: 30,
                patterns: ['chaos', 'apocalypse'],
                specialAttackChance: 0.5,
                enemyMoveSpeed: 0.05
            }
        ];
        
        const ENEMY_TYPES = [
            { name: '–î–æ–¥', emoji: 'üî•', color: '#8b4513' },
            { name: '–ü—Ä–∞–¥–æ–¥', emoji: 'üë¥üî•', color: '#654321' },
            { name: '–ü—Ä–∞–ø—Ä–∞–¥–æ–¥', emoji: 'üë¥üë¥', color: '#4a3520' },
            { name: '–°—É–ø–µ—Ä –ü—Ä–∞–ø—Ä–∞–¥–æ–¥', emoji: '‚≠êüë¥', color: '#3d2914' },
            { name: '–î–æ–¥–æ—Å', emoji: 'ü¶§', color: '#2d1f0f' },
            { name: '–£–ª—å—Ç—Ä–∞–¥–æ–¥–æ—Å', emoji: 'üíÄü¶§', color: '#1a1209' },
            { name: '–£–ª—å—Ç—Ä–∞ –û–º–µ–≥–∞', emoji: 'üåüüíÄ', color: '#0a0604' },
            { name: '–ë–û–°–° –ë–ê–ù–ò', emoji: 'üëëüî•', color: '#000000' },
            { name: '–ë–û–ì –ü–ê–†–ê', emoji: '‚ò†Ô∏èüëë', color: '#220000' }
        ];
        
        let game = {
            running: false,
            player: null,
            temperature: 0,
            enemies: [],
            projectiles: [],
            particles: [],
            keys: {},
            tempRate: 10,
            screenShake: 0,
            lastPlayerPhrase: 0,
            lastEnemyPhrase: 0
        };
        
        // Controls
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ —Ä–µ—á–µ–≤–æ–≥–æ –ø—É–∑—ã—Ä—è
        function showSpeechBubble(x, y, text, isEnemy = false) {
            const container = document.getElementById('speechContainer');
            const bubble = document.createElement('div');
            bubble.className = `speech-bubble ${isEnemy ? 'enemy' : ''}`;
            bubble.textContent = text;
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ canvas
            const canvasRect = canvas.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            
            // Scale for mobile
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;
            
            bubble.style.left = `${x / scaleX - 30}px`;
            bubble.style.top = `${y / scaleY - 50}px`;
            
            container.appendChild(bubble);
            
            // –£–¥–∞–ª—è–µ–º —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
            setTimeout(() => {
                bubble.style.animation = 'bubbleFade 0.5s ease-out forwards';
                setTimeout(() => bubble.remove(), 500);
            }, 2000);
        }
        
        // –§—Ä–∞–∑–∞ –∏–≥—Ä–æ–∫–∞
        function playerSpeak() {
            if (!game.running) return;
            const phrase = PLAYER_PHRASES[Math.floor(Math.random() * PLAYER_PHRASES.length)];
            showSpeechBubble(game.player.x, game.player.y, phrase, false);
        }
        
        // –§—Ä–∞–∑–∞ –≤—Ä–∞–≥–∞
        function enemySpeak(enemy) {
            if (!game.running) return;
            const phrase = ENEMY_PHRASES[Math.floor(Math.random() * ENEMY_PHRASES.length)];
            showSpeechBubble(enemy.x, enemy.y, phrase, true);
        }
        
        function startGame() {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            document.getElementById('gameScreen').classList.add('flex');
            
            // –û—á–∏—â–∞–µ–º –ø—É–∑—ã—Ä–∏
            document.getElementById('speechContainer').innerHTML = '';
            
            game = {
                running: true,
                player: { x: 100, y: 250, vx: 0, vy: 0, health: 100, formIndex: 0, invincible: 0 },
                temperature: 0,
                enemies: [],
                projectiles: [],
                particles: [],
                keys: {},
                tempRate: 50, // –£–í–ï–õ–ò–ß–ï–ù–û –í 5 –†–ê–ó (–±—ã–ª–æ 10)
                screenShake: 0,
                lastPlayerPhrase: Date.now(),
                lastEnemyPhrase: Date.now()
            };
            
            spawnEnemies();
            updateUI();
            gameLoop();
            
            // –ü–µ—Ä–≤–∞—è —Ñ—Ä–∞–∑–∞ –∏–≥—Ä–æ–∫–∞
            setTimeout(() => playerSpeak(), 1000);
        }
        
        function spawnEnemies() {
            game.enemies = [];
            const diff = DIFFICULTY[game.player.formIndex];
            const enemyType = ENEMY_TYPES[Math.min(game.player.formIndex, ENEMY_TYPES.length - 1)];
            
            for (let i = 0; i < diff.enemies; i++) {
                game.enemies.push({
                    x: canvas.width - 80,
                    y: 100 + (i * (canvas.height - 200) / Math.max(1, diff.enemies - 1)),
                    targetY: 100 + Math.random() * (canvas.height - 200),
                    lastAttack: Date.now() + i * 500,
                    type: enemyType,
                    size: 35 + game.player.formIndex * 3,
                    angle: 0
                });
            }
        }
        
        function restartGame() {
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('victoryScreen').classList.add('hidden');
            startGame();
        }
        
        function updateUI() {
            const form = FORMS[game.player.formIndex];
            document.getElementById('playerForm').textContent = form.name;
            document.getElementById('temperature').textContent = Math.floor(game.temperature).toLocaleString();
            document.getElementById('health').textContent = Math.max(0, Math.floor(game.player.health));
            document.getElementById('level').textContent = game.player.formIndex + 1;
            
            const enemyType = ENEMY_TYPES[Math.min(game.player.formIndex, ENEMY_TYPES.length - 1)];
            const diff = DIFFICULTY[game.player.formIndex];
            document.getElementById('enemyInfo').textContent = `–í—Ä–∞–≥–∏: ${diff.enemies}x ${enemyType.emoji} ${enemyType.name}`;
            
            const progress = (game.temperature / form.targetTemp) * 100;
            document.getElementById('tempBar').style.width = Math.min(100, progress) + '%';
            document.getElementById('nextForm').textContent = form.targetTemp === Infinity ? '‚àû' : form.targetTemp.toLocaleString() + '¬∞C';
            
            // Difficulty stars
            const stars = '‚òÖ'.repeat(game.player.formIndex + 1) + '‚òÜ'.repeat(8 - game.player.formIndex);
            document.getElementById('difficultyInfo').textContent = `–°–ª–æ–∂–Ω–æ—Å—Ç—å: ${stars}`;
        }
        
        function gameLoop() {
            if (!game.running) return;
            
            update();
            render();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        function createAttackPattern(enemy, pattern, diff) {
            const angle = Math.atan2(game.player.y - enemy.y, game.player.x - enemy.x);
            
            switch(pattern) {
                case 'aimed':
                    game.projectiles.push(createProjectile(enemy.x, enemy.y, angle, diff));
                    break;
                    
                case 'spread3':
                    for (let i = -1; i <= 1; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + i * 0.3, diff));
                    }
                    break;
                    
                case 'spread5':
                    for (let i = -2; i <= 2; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + i * 0.25, diff));
                    }
                    break;
                    
                case 'circle':
                    for (let i = 0; i < 8; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 8) * i, diff));
                    }
                    break;
                    
                case 'wave':
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            if (game.running) {
                                game.projectiles.push(createProjectile(enemy.x, enemy.y, angle + Math.sin(Date.now() / 100) * 0.5, diff));
                            }
                        }, i * 100);
                    }
                    break;
                    
                case 'spiral':
                    enemy.angle = (enemy.angle || 0) + 0.5;
                    for (let i = 0; i < 3; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, enemy.angle + (Math.PI * 2 / 3) * i, diff));
                    }
                    break;
                    
                case 'cross':
                    for (let i = 0; i < 4; i++) {
                        const crossAngle = (Math.PI / 2) * i;
                        for (let j = 0; j < 3; j++) {
                            setTimeout(() => {
                                if (game.running) {
                                    game.projectiles.push(createProjectile(enemy.x, enemy.y, crossAngle, diff));
                                }
                            }, j * 150);
                        }
                    }
                    break;
                    
                case 'burst':
                    for (let i = 0; i < 12; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 12) * i, diff));
                    }
                    setTimeout(() => {
                        if (game.running) {
                            for (let i = 0; i < 12; i++) {
                                game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 12) * i + 0.26, diff));
                            }
                        }
                    }, 200);
                    break;
                    
                case 'chaos':
                    for (let i = 0; i < 8; i++) {
                        const chaosAngle = Math.random() * Math.PI * 2;
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, chaosAngle, diff));
                    }
                    break;
                    
                case 'apocalypse':
                    // Massive attack pattern
                    for (let i = 0; i < 16; i++) {
                        game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 16) * i, diff));
                    }
                    for (let wave = 1; wave <= 3; wave++) {
                        setTimeout(() => {
                            if (game.running) {
                                for (let i = 0; i < 16; i++) {
                                    game.projectiles.push(createProjectile(enemy.x, enemy.y, (Math.PI * 2 / 16) * i + wave * 0.2, diff));
                                }
                            }
                        }, wave * 150);
                    }
                    break;
            }
        }
        
        function createProjectile(x, y, angle, diff) {
            return {
                x: x,
                y: y,
                vx: Math.cos(angle) * diff.projectileSpeed,
                vy: Math.sin(angle) * diff.projectileSpeed,
                size: 6 + game.player.formIndex,
                damage: diff.damage
            };
        }
        
        function update() {
            const form = FORMS[game.player.formIndex];
            const diff = DIFFICULTY[game.player.formIndex];
            
            // Player movement - slightly faster to help with difficulty
            const speed = 5 + game.player.formIndex * 0.3;
            
            // Keyboard controls
            let inputX = 0;
            let inputY = 0;
            
            if (game.keys['w'] || game.keys['arrowup']) inputY = -1;
            else if (game.keys['s'] || game.keys['arrowdown']) inputY = 1;
            
            if (game.keys['a'] || game.keys['arrowleft']) inputX = -1;
            else if (game.keys['d'] || game.keys['arrowright']) inputX = 1;
            
            // Joystick controls (override keyboard if active)
            if (joystick.active || Math.abs(joystick.moveX) > 0.1 || Math.abs(joystick.moveY) > 0.1) {
                inputX = joystick.moveX;
                inputY = joystick.moveY;
            }
            
            // Apply movement
            if (Math.abs(inputX) > 0.1) {
                game.player.vx = inputX * speed;
            } else {
                game.player.vx *= 0.85;
            }
            
            if (Math.abs(inputY) > 0.1) {
                game.player.vy = inputY * speed;
            } else {
                game.player.vy *= 0.85;
            }
            
            game.player.x += game.player.vx;
            game.player.y += game.player.vy;
            
            // Boundaries
            game.player.x = Math.max(form.size, Math.min(canvas.width - form.size - 150, game.player.x));
            game.player.y = Math.max(form.size, Math.min(canvas.height - form.size, game.player.y));
            
            // Increase temperature (–£–í–ï–õ–ò–ß–ï–ù–û –í 5 –†–ê–ó - —Ç–µ–ø–µ—Ä—å tempRate = 50 –≤–º–µ—Å—Ç–æ 10)
            game.temperature += (game.tempRate + game.player.formIndex * 25) / 60;
            
            // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ —Ñ—Ä–∞–∑—ã –∏–≥—Ä–æ–∫–∞ (–∫–∞–∂–¥—ã–µ 3-6 —Å–µ–∫—É–Ω–¥)
            if (Date.now() - game.lastPlayerPhrase > 3000 + Math.random() * 3000) {
                game.lastPlayerPhrase = Date.now();
                playerSpeak();
            }
            
            // Check for transformation
            if (game.temperature >= form.targetTemp) {
                if (game.player.formIndex < FORMS.length - 1) {
                    game.player.formIndex++;
                    game.player.invincible = 180; // Longer invincibility on transform
                    game.player.health = Math.min(100, game.player.health + 30); // Heal on transform
                    game.tempRate *= 1.8; // –£—Å–∫–æ—Ä–µ–Ω–∏–µ —Ä–æ—Å—Ç–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã –ø—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                    
                    // Respawn enemies with new difficulty
                    spawnEnemies();
                    
                    // Transformation particles
                    for (let i = 0; i < 50; i++) {
                        game.particles.push({
                            x: game.player.x,
                            y: game.player.y,
                            vx: (Math.random() - 0.5) * 15,
                            vy: (Math.random() - 0.5) * 15,
                            life: 90,
                            color: FORMS[game.player.formIndex].color
                        });
                    }
                    
                    game.screenShake = 20;
                    
                    // –§—Ä–∞–∑–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                    setTimeout(() => {
                        if (game.running) {
                            showSpeechBubble(game.player.x, game.player.y, "–Ø –≠–í–û–õ–Æ–¶–ò–û–ù–ò–†–£–Æ!", false);
                        }
                    }, 100);
                    
                    // Check victory
                    if (game.player.formIndex === FORMS.length - 1) {
                        setTimeout(() => {
                            game.running = false;
                            document.getElementById('gameScreen').classList.add('hidden');
                            document.getElementById('victoryScreen').classList.remove('hidden');
                        }, 2000);
                    }
                }
            }
            
            // Enemy behavior
            game.enemies.forEach((enemy, idx) => {
                // Move enemy
                if (Math.abs(enemy.y - enemy.targetY) < 10) {
                    enemy.targetY = 50 + Math.random() * (canvas.height - 100);
                }
                enemy.y += (enemy.targetY - enemy.y) * diff.enemyMoveSpeed;
                
                // Horizontal movement at higher levels
                if (game.player.formIndex >= 4) {
                    enemy.x = canvas.width - 80 + Math.sin(Date.now() / 500 + idx) * 30;
                }
                
                // Attack
                if (Date.now() - enemy.lastAttack > diff.attackSpeed) {
                    enemy.lastAttack = Date.now();
                    
                    // Choose attack pattern
                    const patterns = diff.patterns;
                    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
                    createAttackPattern(enemy, pattern, diff);
                    
                    // –§—Ä–∞–∑–∞ –≤—Ä–∞–≥–∞ –ø—Ä–∏ –∞—Ç–∞–∫–µ (—Å —à–∞–Ω—Å–æ–º 15%)
                    if (Math.random() < 0.15 && Date.now() - game.lastEnemyPhrase > 2000) {
                        game.lastEnemyPhrase = Date.now();
                        enemySpeak(enemy);
                    }
                    
                    // Special attack chance
                    if (Math.random() < diff.specialAttackChance) {
                        setTimeout(() => {
                            if (game.running) {
                                const specialPattern = patterns[patterns.length - 1];
                                createAttackPattern(enemy, specialPattern, diff);
                            }
                        }, 300);
                    }
                }
            });
            
            // Update projectiles
            game.projectiles = game.projectiles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                
                // Check collision with player
                if (game.player.invincible <= 0) {
                    const dx = p.x - game.player.x;
                    const dy = p.y - game.player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < form.size + p.size) {
                        game.player.health -= p.damage;
                        game.player.invincible = 20;
                        game.screenShake = 10;
                        
                        // –§—Ä–∞–∑–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —É—Ä–æ–Ω–∞ (—Å —à–∞–Ω—Å–æ–º 25%)
                        if (Math.random() < 0.25) {
                            const hitPhrases = [
                                "–ê–π, –±–ª*—Ç—å!",
                                "–°—É–∫–∞!",
                                "–ë–æ–ª—å–Ω–æ!",
                                "–¢—ã –±–ª*–¥—å, –¥*–ª–±–∞—ë–± –Ω–∞—Ö*–π?",
                                "–ü*–∑–¥–µ—Ü!",
                                "–ù–∞—Ö*—Ä!"
                            ];
                            showSpeechBubble(game.player.x, game.player.y, hitPhrases[Math.floor(Math.random() * hitPhrases.length)], false);
                        }
                        
                        // Hit particles
                        for (let i = 0; i < 15; i++) {
                            game.particles.push({
                                x: game.player.x,
                                y: game.player.y,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                life: 30,
                                color: '#ff0000'
                            });
                        }
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                        return false;
                    }
                }
                
                return p.x > -50 && p.x < canvas.width + 50 && p.y > -50 && p.y < canvas.height + 50;
            });
            
            // Update particles
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                return p.life > 0;
            });
            
            // Update invincibility and screen shake
            if (game.player.invincible > 0) game.player.invincible--;
            if (game.screenShake > 0) game.screenShake--;
        }
        
        function render() {
            // Screen shake
            ctx.save();
            if (game.screenShake > 0) {
                ctx.translate(
                    (Math.random() - 0.5) * game.screenShake,
                    (Math.random() - 0.5) * game.screenShake
                );
            }
            
            // Background
            const heat = Math.min(1, game.temperature / 1000000);
            const formHeat = game.player.formIndex / 8;
            ctx.fillStyle = `rgb(${40 + (heat + formHeat) * 80}, ${20 - heat * 15}, ${20 - heat * 15})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Danger zone indicator (right side where enemies are)
            ctx.fillStyle = `rgba(255, 0, 0, ${0.05 + formHeat * 0.1})`;
            ctx.fillRect(canvas.width - 200, 0, 200, canvas.height);
            
            // Steam effect
            const steamCount = 3 + game.player.formIndex * 2;
            for (let i = 0; i < steamCount; i++) {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.02 + heat * 0.08})`;
                ctx.beginPath();
                ctx.arc(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    15 + Math.random() * 40,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Draw particles
            game.particles.forEach(p => {
                ctx.globalAlpha = p.life / 90;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4 + (90 - p.life) / 20, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // Draw projectiles
            game.projectiles.forEach(p => {
                // Outer glow
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 10;
                
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            });
            
            // Draw enemies
            game.enemies.forEach((enemy, idx) => {
                const pulseSize = Math.sin(Date.now() / 200 + idx) * 3;
                
                // Enemy glow
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20 + game.player.formIndex * 3;
                
                ctx.fillStyle = enemy.type.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size + pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner circle
                ctx.fillStyle = `rgba(255, 100, 0, 0.5)`;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Enemy emoji
                ctx.font = `${18 + game.player.formIndex * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enemy.type.emoji, enemy.x, enemy.y);
            });
            
            // Draw player
            const form = FORMS[game.player.formIndex];
            
            if (game.player.invincible <= 0 || Math.floor(game.player.invincible / 4) % 2 === 0) {
                // Player glow
                ctx.shadowColor = form.color;
                ctx.shadowBlur = 20 + game.player.formIndex * 5;
                
                // Outer ring for higher forms
                if (game.player.formIndex >= 3) {
                    ctx.strokeStyle = form.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(game.player.x, game.player.y, form.size + 8 + Math.sin(Date.now() / 100) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = form.color;
                ctx.beginPath();
                ctx.arc(game.player.x, game.player.y, form.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Player name
                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.min(form.size - 4, 12)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const displayName = form.name.length > 8 ? form.name.substring(0, 7) + '..' : form.name;
                ctx.fillText(displayName, game.player.x, game.player.y);
            }
            
            // Health bar
            ctx.fillStyle = '#333';
            ctx.fillRect(10, 10, 150, 15);
            const healthColor = game.player.health > 50 ? '#00ff00' : game.player.health > 25 ? '#ffff00' : '#ff0000';
            ctx.fillStyle = healthColor;
            ctx.fillRect(10, 10, Math.max(0, game.player.health * 1.5), 15);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(10, 10, 150, 15);
            
            // Temperature display
            ctx.fillStyle = '#fff';
            ctx.font = '10px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText(`üå°Ô∏è ${Math.floor(game.temperature).toLocaleString()}¬∞C`, 10, 42);
            
            // Level/Form indicator
            ctx.fillStyle = form.color;
            ctx.fillText(`${form.name}`, 10, 58);
            
            ctx.restore();
        }
        
        function gameOver() {
            game.running = false;
            
            // –§–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—Ä–∞–∑–∞
            showSpeechBubble(game.player.x, game.player.y, "–Ø –°–ì–û–†–ï–õ!!!", false);
            
            setTimeout(() => {
                document.getElementById('gameScreen').classList.add('hidden');
                document.getElementById('gameOverScreen').classList.remove('hidden');
                document.getElementById('finalForm').textContent = FORMS[game.player.formIndex].name;
                document.getElementById('finalTemp').textContent = Math.floor(game.temperature).toLocaleString();
                document.getElementById('finalLevel').textContent = `${game.player.formIndex + 1}/9`;
            }, 500);
        }
        
        // Steam effects
        function createSteam() {
            if (!game.running) return;
            
            const container = document.getElementById('steamContainer');
            const steam = document.createElement('div');
            steam.className = 'steam';
            steam.style.left = Math.random() * 100 + '%';
            steam.style.bottom = '0';
            steam.style.animationDelay = Math.random() * 2 + 's';
            container.appendChild(steam);
            
            setTimeout(() => steam.remove(), 2000);
        }
        
        setInterval(createSteam, 300);
        
        // Prevent default touch behavior on game area
        document.body.addEventListener('touchstart', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                // Don't prevent default for buttons
            }
        }, { passive: true });
    </script>
</body>
</html>
